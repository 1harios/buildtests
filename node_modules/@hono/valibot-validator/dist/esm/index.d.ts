import type { Context, Env, Input as HonoInput, MiddlewareHandler, ValidationTargets } from 'hono';
import type { GenericSchema, GenericSchemaAsync, InferInput, InferOutput, SafeParseResult } from 'valibot';
type Hook<T extends GenericSchema | GenericSchemaAsync, E extends Env, P extends string> = (result: SafeParseResult<T>, c: Context<E, P>) => Response | Promise<Response> | void | Promise<Response | void>;
type HasUndefined<T> = undefined extends T ? true : false;
export declare const vValidator: <T extends GenericSchema<unknown, unknown, import("valibot").BaseIssue<unknown>> | GenericSchemaAsync<unknown, unknown, import("valibot").BaseIssue<unknown>>, Target extends keyof ValidationTargets, E extends Env, P extends string, In = InferInput<T>, Out = InferOutput<T>, I extends HonoInput = {
    in: HasUndefined<In> extends true ? { [K in Target]?: (K extends "json" ? In : HasUndefined<keyof ValidationTargets[K]> extends true ? { [K2 in keyof In]?: ValidationTargets[K][K2] | undefined; } : { [K2_1 in keyof In]: ValidationTargets[K][K2_1]; }) | undefined; } : { [K_1 in Target]: K_1 extends "json" ? In : HasUndefined<keyof ValidationTargets[K_1]> extends true ? { [K2_2 in keyof In]?: ValidationTargets[K_1][K2_2] | undefined; } : { [K2_3 in keyof In]: ValidationTargets[K_1][K2_3]; }; };
    out: { [K_2 in Target]: Out; };
}, V extends I = I>(target: Target, schema: T, hook?: Hook<T, E, P> | undefined) => MiddlewareHandler<E, P, V>;
export {};
