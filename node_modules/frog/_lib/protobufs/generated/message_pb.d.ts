import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message as Message$1, proto3 } from "@bufbuild/protobuf";
import { UserNameProof } from "./username_proof_pb.js";
/**
 * * Type of hashing scheme used to produce a digest of MessageData
 *
 * @generated from enum HashScheme
 */
export declare enum HashScheme {
    /**
     * @generated from enum value: HASH_SCHEME_NONE = 0;
     */
    NONE = 0,
    /**
     * Default scheme for hashing MessageData
     *
     * @generated from enum value: HASH_SCHEME_BLAKE3 = 1;
     */
    BLAKE3 = 1
}
/**
 * * Type of signature scheme used to sign the Message hash
 *
 * @generated from enum SignatureScheme
 */
export declare enum SignatureScheme {
    /**
     * @generated from enum value: SIGNATURE_SCHEME_NONE = 0;
     */
    NONE = 0,
    /**
     * Ed25519 signature (default)
     *
     * @generated from enum value: SIGNATURE_SCHEME_ED25519 = 1;
     */
    ED25519 = 1,
    /**
     * ECDSA signature using EIP-712 scheme
     *
     * @generated from enum value: SIGNATURE_SCHEME_EIP712 = 2;
     */
    EIP712 = 2
}
/**
 * * Type of the MessageBody
 *
 * @generated from enum MessageType
 */
export declare enum MessageType {
    /**
     * @generated from enum value: MESSAGE_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * Add a new Cast
     *
     * @generated from enum value: MESSAGE_TYPE_CAST_ADD = 1;
     */
    CAST_ADD = 1,
    /**
     * Remove an existing Cast
     *
     * @generated from enum value: MESSAGE_TYPE_CAST_REMOVE = 2;
     */
    CAST_REMOVE = 2,
    /**
     * Add a Reaction to a Cast
     *
     * @generated from enum value: MESSAGE_TYPE_REACTION_ADD = 3;
     */
    REACTION_ADD = 3,
    /**
     * Remove a Reaction from a Cast
     *
     * @generated from enum value: MESSAGE_TYPE_REACTION_REMOVE = 4;
     */
    REACTION_REMOVE = 4,
    /**
     * Add a new Link
     *
     * @generated from enum value: MESSAGE_TYPE_LINK_ADD = 5;
     */
    LINK_ADD = 5,
    /**
     * Remove an existing Link
     *
     * @generated from enum value: MESSAGE_TYPE_LINK_REMOVE = 6;
     */
    LINK_REMOVE = 6,
    /**
     * Add a Verification of an Ethereum Address
     *
     * @generated from enum value: MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS = 7;
     */
    VERIFICATION_ADD_ETH_ADDRESS = 7,
    /**
     * Remove a Verification
     *
     * @generated from enum value: MESSAGE_TYPE_VERIFICATION_REMOVE = 8;
     */
    VERIFICATION_REMOVE = 8,
    /**
     *  Deprecated
     *  MESSAGE_TYPE_SIGNER_ADD = 9; // Add a new Ed25519 key pair that signs messages for a user
     *  MESSAGE_TYPE_SIGNER_REMOVE = 10; // Remove an Ed25519 key pair that signs messages for a user
     *
     * Add metadata about a user
     *
     * @generated from enum value: MESSAGE_TYPE_USER_DATA_ADD = 11;
     */
    USER_DATA_ADD = 11,
    /**
     * Add or replace a username proof
     *
     * @generated from enum value: MESSAGE_TYPE_USERNAME_PROOF = 12;
     */
    USERNAME_PROOF = 12,
    /**
     * A Farcaster Frame action
     *
     * @generated from enum value: MESSAGE_TYPE_FRAME_ACTION = 13;
     */
    FRAME_ACTION = 13
}
/**
 * * Farcaster network the message is intended for
 *
 * @generated from enum FarcasterNetwork
 */
export declare enum FarcasterNetwork {
    /**
     * @generated from enum value: FARCASTER_NETWORK_NONE = 0;
     */
    NONE = 0,
    /**
     * Public primary network
     *
     * @generated from enum value: FARCASTER_NETWORK_MAINNET = 1;
     */
    MAINNET = 1,
    /**
     * Public test network
     *
     * @generated from enum value: FARCASTER_NETWORK_TESTNET = 2;
     */
    TESTNET = 2,
    /**
     * Private test network
     *
     * @generated from enum value: FARCASTER_NETWORK_DEVNET = 3;
     */
    DEVNET = 3
}
/**
 * * Type of UserData
 *
 * @generated from enum UserDataType
 */
export declare enum UserDataType {
    /**
     * @generated from enum value: USER_DATA_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * Profile Picture for the user
     *
     * @generated from enum value: USER_DATA_TYPE_PFP = 1;
     */
    PFP = 1,
    /**
     * Display Name for the user
     *
     * @generated from enum value: USER_DATA_TYPE_DISPLAY = 2;
     */
    DISPLAY = 2,
    /**
     * Bio for the user
     *
     * @generated from enum value: USER_DATA_TYPE_BIO = 3;
     */
    BIO = 3,
    /**
     * URL of the user
     *
     * @generated from enum value: USER_DATA_TYPE_URL = 5;
     */
    URL = 5,
    /**
     * Preferred Name for the user
     *
     * @generated from enum value: USER_DATA_TYPE_USERNAME = 6;
     */
    USERNAME = 6
}
/**
 * * Type of Reaction
 *
 * @generated from enum ReactionType
 */
export declare enum ReactionType {
    /**
     * @generated from enum value: REACTION_TYPE_NONE = 0;
     */
    NONE = 0,
    /**
     * Like the target cast
     *
     * @generated from enum value: REACTION_TYPE_LIKE = 1;
     */
    LIKE = 1,
    /**
     * Share target cast to the user's audience
     *
     * @generated from enum value: REACTION_TYPE_RECAST = 2;
     */
    RECAST = 2
}
/**
 * * Type of Protocol to disambiguate verification addresses
 *
 * @generated from enum Protocol
 */
export declare enum Protocol {
    /**
     * @generated from enum value: PROTOCOL_ETHEREUM = 0;
     */
    ETHEREUM = 0,
    /**
     * @generated from enum value: PROTOCOL_SOLANA = 1;
     */
    SOLANA = 1
}
/**
 * *
 * A Message is a delta operation on the Farcaster network. The message protobuf is an envelope
 * that wraps a MessageData object and contains a hash and signature which can verify its authenticity.
 *
 * @generated from message Message
 */
export declare class Message extends Message$1<Message> {
    /**
     * Contents of the message
     *
     * @generated from field: MessageData data = 1;
     */
    data?: MessageData;
    /**
     * Hash digest of data
     *
     * @generated from field: bytes hash = 2;
     */
    hash: Uint8Array;
    /**
     * Hash scheme that produced the hash digest
     *
     * @generated from field: HashScheme hash_scheme = 3;
     */
    hashScheme: HashScheme;
    /**
     * Signature of the hash digest
     *
     * @generated from field: bytes signature = 4;
     */
    signature: Uint8Array;
    /**
     * Signature scheme that produced the signature
     *
     * @generated from field: SignatureScheme signature_scheme = 5;
     */
    signatureScheme: SignatureScheme;
    /**
     * Public key or address of the key pair that produced the signature
     *
     * @generated from field: bytes signer = 6;
     */
    signer: Uint8Array;
    /**
     * MessageData serialized to bytes if using protobuf serialization other than ts-proto
     *
     * @generated from field: optional bytes data_bytes = 7;
     */
    dataBytes?: Uint8Array;
    constructor(data?: PartialMessage<Message>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "Message";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Message;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Message;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Message;
    static equals(a: Message | PlainMessage<Message> | undefined, b: Message | PlainMessage<Message> | undefined): boolean;
}
/**
 * *
 * A MessageData object contains properties common to all messages and wraps a body object which
 * contains properties specific to the MessageType.
 *
 * @generated from message MessageData
 */
export declare class MessageData extends Message$1<MessageData> {
    /**
     * Type of message contained in the body
     *
     * @generated from field: MessageType type = 1;
     */
    type: MessageType;
    /**
     * Farcaster ID of the user producing the message
     *
     * @generated from field: uint64 fid = 2;
     */
    fid: bigint;
    /**
     * Farcaster epoch timestamp in seconds
     *
     * @generated from field: uint32 timestamp = 3;
     */
    timestamp: number;
    /**
     * Farcaster network the message is intended for
     *
     * @generated from field: FarcasterNetwork network = 4;
     */
    network: FarcasterNetwork;
    /**
     * @generated from oneof MessageData.body
     */
    body: {
        /**
         * @generated from field: CastAddBody cast_add_body = 5;
         */
        value: CastAddBody;
        case: "castAddBody";
    } | {
        /**
         * @generated from field: CastRemoveBody cast_remove_body = 6;
         */
        value: CastRemoveBody;
        case: "castRemoveBody";
    } | {
        /**
         * @generated from field: ReactionBody reaction_body = 7;
         */
        value: ReactionBody;
        case: "reactionBody";
    } | {
        /**
         * @generated from field: VerificationAddAddressBody verification_add_address_body = 9;
         */
        value: VerificationAddAddressBody;
        case: "verificationAddAddressBody";
    } | {
        /**
         * @generated from field: VerificationRemoveBody verification_remove_body = 10;
         */
        value: VerificationRemoveBody;
        case: "verificationRemoveBody";
    } | {
        /**
         * SignerAddBody signer_add_body = 11; // Deprecated
         *
         * @generated from field: UserDataBody user_data_body = 12;
         */
        value: UserDataBody;
        case: "userDataBody";
    } | {
        /**
         * SignerRemoveBody signer_remove_body = 13; // Deprecated
         *
         * @generated from field: LinkBody link_body = 14;
         */
        value: LinkBody;
        case: "linkBody";
    } | {
        /**
         * @generated from field: UserNameProof username_proof_body = 15;
         */
        value: UserNameProof;
        case: "usernameProofBody";
    } | {
        /**
         * @generated from field: FrameActionBody frame_action_body = 16;
         */
        value: FrameActionBody;
        case: "frameActionBody";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<MessageData>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "MessageData";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MessageData;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MessageData;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MessageData;
    static equals(a: MessageData | PlainMessage<MessageData> | undefined, b: MessageData | PlainMessage<MessageData> | undefined): boolean;
}
/**
 * * Adds metadata about a user
 *
 * @generated from message UserDataBody
 */
export declare class UserDataBody extends Message$1<UserDataBody> {
    /**
     * Type of metadata
     *
     * @generated from field: UserDataType type = 1;
     */
    type: UserDataType;
    /**
     * Value of the metadata
     *
     * @generated from field: string value = 2;
     */
    value: string;
    constructor(data?: PartialMessage<UserDataBody>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "UserDataBody";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserDataBody;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserDataBody;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserDataBody;
    static equals(a: UserDataBody | PlainMessage<UserDataBody> | undefined, b: UserDataBody | PlainMessage<UserDataBody> | undefined): boolean;
}
/**
 * @generated from message Embed
 */
export declare class Embed extends Message$1<Embed> {
    /**
     * @generated from oneof Embed.embed
     */
    embed: {
        /**
         * @generated from field: string url = 1;
         */
        value: string;
        case: "url";
    } | {
        /**
         * @generated from field: CastId cast_id = 2;
         */
        value: CastId;
        case: "castId";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<Embed>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "Embed";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Embed;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Embed;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Embed;
    static equals(a: Embed | PlainMessage<Embed> | undefined, b: Embed | PlainMessage<Embed> | undefined): boolean;
}
/**
 * * Adds a new Cast
 *
 * @generated from message CastAddBody
 */
export declare class CastAddBody extends Message$1<CastAddBody> {
    /**
     * URLs to be embedded in the cast
     *
     * @generated from field: repeated string embeds_deprecated = 1;
     */
    embedsDeprecated: string[];
    /**
     * Fids mentioned in the cast
     *
     * @generated from field: repeated uint64 mentions = 2;
     */
    mentions: bigint[];
    /**
     * @generated from oneof CastAddBody.parent
     */
    parent: {
        /**
         * Parent cast of the cast
         *
         * @generated from field: CastId parent_cast_id = 3;
         */
        value: CastId;
        case: "parentCastId";
    } | {
        /**
         * Parent URL
         *
         * @generated from field: string parent_url = 7;
         */
        value: string;
        case: "parentUrl";
    } | {
        case: undefined;
        value?: undefined;
    };
    /**
     * Text of the cast
     *
     * @generated from field: string text = 4;
     */
    text: string;
    /**
     * Positions of the mentions in the text
     *
     * @generated from field: repeated uint32 mentions_positions = 5;
     */
    mentionsPositions: number[];
    /**
     * URLs or cast ids to be embedded in the cast
     *
     * @generated from field: repeated Embed embeds = 6;
     */
    embeds: Embed[];
    constructor(data?: PartialMessage<CastAddBody>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "CastAddBody";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CastAddBody;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CastAddBody;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CastAddBody;
    static equals(a: CastAddBody | PlainMessage<CastAddBody> | undefined, b: CastAddBody | PlainMessage<CastAddBody> | undefined): boolean;
}
/**
 * * Removes an existing Cast
 *
 * @generated from message CastRemoveBody
 */
export declare class CastRemoveBody extends Message$1<CastRemoveBody> {
    /**
     * Hash of the cast to remove
     *
     * @generated from field: bytes target_hash = 1;
     */
    targetHash: Uint8Array;
    constructor(data?: PartialMessage<CastRemoveBody>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "CastRemoveBody";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CastRemoveBody;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CastRemoveBody;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CastRemoveBody;
    static equals(a: CastRemoveBody | PlainMessage<CastRemoveBody> | undefined, b: CastRemoveBody | PlainMessage<CastRemoveBody> | undefined): boolean;
}
/**
 * * Identifier used to look up a Cast
 *
 * @generated from message CastId
 */
export declare class CastId extends Message$1<CastId> {
    /**
     * Fid of the user who created the cast
     *
     * @generated from field: uint64 fid = 1;
     */
    fid: bigint;
    /**
     * Hash of the cast
     *
     * @generated from field: bytes hash = 2;
     */
    hash: Uint8Array;
    constructor(data?: PartialMessage<CastId>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "CastId";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CastId;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CastId;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CastId;
    static equals(a: CastId | PlainMessage<CastId> | undefined, b: CastId | PlainMessage<CastId> | undefined): boolean;
}
/**
 * * Adds or removes a Reaction from a Cast
 *
 * @generated from message ReactionBody
 */
export declare class ReactionBody extends Message$1<ReactionBody> {
    /**
     * Type of reaction
     *
     * @generated from field: ReactionType type = 1;
     */
    type: ReactionType;
    /**
     * @generated from oneof ReactionBody.target
     */
    target: {
        /**
         * CastId of the Cast to react to
         *
         * @generated from field: CastId target_cast_id = 2;
         */
        value: CastId;
        case: "targetCastId";
    } | {
        /**
         * URL to react to
         *
         * @generated from field: string target_url = 3;
         */
        value: string;
        case: "targetUrl";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<ReactionBody>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "ReactionBody";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReactionBody;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReactionBody;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReactionBody;
    static equals(a: ReactionBody | PlainMessage<ReactionBody> | undefined, b: ReactionBody | PlainMessage<ReactionBody> | undefined): boolean;
}
/**
 * * Adds a Verification of ownership of an Address based on Protocol
 *
 * @generated from message VerificationAddAddressBody
 */
export declare class VerificationAddAddressBody extends Message$1<VerificationAddAddressBody> {
    /**
     * Address being verified for a given Protocol
     *
     * @generated from field: bytes address = 1;
     */
    address: Uint8Array;
    /**
     * Signature produced by the user's address for a given Protocol
     *
     * @generated from field: bytes claim_signature = 2;
     */
    claimSignature: Uint8Array;
    /**
     * Hash of the latest Ethereum block when the signature was produced
     *
     * @generated from field: bytes block_hash = 3;
     */
    blockHash: Uint8Array;
    /**
     * Type of verification. 0 = EOA, 1 = contract
     *
     * @generated from field: uint32 verification_type = 4;
     */
    verificationType: number;
    /**
     * 0 for EOA verifications, 1 or 10 for contract verifications
     *
     * @generated from field: uint32 chain_id = 5;
     */
    chainId: number;
    /**
     * Protocol of the Verification
     *
     * @generated from field: Protocol protocol = 7;
     */
    protocol: Protocol;
    constructor(data?: PartialMessage<VerificationAddAddressBody>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "VerificationAddAddressBody";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerificationAddAddressBody;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerificationAddAddressBody;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerificationAddAddressBody;
    static equals(a: VerificationAddAddressBody | PlainMessage<VerificationAddAddressBody> | undefined, b: VerificationAddAddressBody | PlainMessage<VerificationAddAddressBody> | undefined): boolean;
}
/**
 * * Removes a Verification of a given protocol
 *
 * @generated from message VerificationRemoveBody
 */
export declare class VerificationRemoveBody extends Message$1<VerificationRemoveBody> {
    /**
     * Address of the Verification to remove
     *
     * @generated from field: bytes address = 1;
     */
    address: Uint8Array;
    /**
     * Protocol of the Verification to remove
     *
     * @generated from field: Protocol protocol = 2;
     */
    protocol: Protocol;
    constructor(data?: PartialMessage<VerificationRemoveBody>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "VerificationRemoveBody";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VerificationRemoveBody;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VerificationRemoveBody;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VerificationRemoveBody;
    static equals(a: VerificationRemoveBody | PlainMessage<VerificationRemoveBody> | undefined, b: VerificationRemoveBody | PlainMessage<VerificationRemoveBody> | undefined): boolean;
}
/**
 * * Adds or removes a Link
 *
 * @generated from message LinkBody
 */
export declare class LinkBody extends Message$1<LinkBody> {
    /**
     * Type of link, <= 8 characters
     *
     * @generated from field: string type = 1;
     */
    type: string;
    /**
     * User-defined timestamp that preserves original timestamp when message.data.timestamp needs to be updated for compaction
     *
     * @generated from field: optional uint32 displayTimestamp = 2;
     */
    displayTimestamp?: number;
    /**
     * @generated from oneof LinkBody.target
     */
    target: {
        /**
         * The fid the link relates to
         *
         * @generated from field: uint64 target_fid = 3;
         */
        value: bigint;
        case: "targetFid";
    } | {
        case: undefined;
        value?: undefined;
    };
    constructor(data?: PartialMessage<LinkBody>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "LinkBody";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LinkBody;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LinkBody;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LinkBody;
    static equals(a: LinkBody | PlainMessage<LinkBody> | undefined, b: LinkBody | PlainMessage<LinkBody> | undefined): boolean;
}
/**
 * * A Farcaster Frame action
 *
 * @generated from message FrameActionBody
 */
export declare class FrameActionBody extends Message$1<FrameActionBody> {
    /**
     * URL of the Frame triggering the action
     *
     * @generated from field: bytes url = 1;
     */
    url: Uint8Array;
    /**
     * The index of the button pressed (1-4)
     *
     * @generated from field: uint32 button_index = 2;
     */
    buttonIndex: number;
    /**
     * The cast which contained the frame url
     *
     * @generated from field: CastId cast_id = 3;
     */
    castId?: CastId;
    /**
     * Text input from the user, if present
     *
     * @generated from field: bytes input_text = 4;
     */
    inputText: Uint8Array;
    /**
     * Serialized frame state value
     *
     * @generated from field: bytes state = 5;
     */
    state: Uint8Array;
    /**
     * Chain-specific transaction ID for tx actions
     *
     * @generated from field: bytes transaction_id = 6;
     */
    transactionId: Uint8Array;
    /**
     * Chain-specific address for tx actions
     *
     * @generated from field: bytes address = 7;
     */
    address: Uint8Array;
    constructor(data?: PartialMessage<FrameActionBody>);
    static readonly runtime: typeof proto3;
    static readonly typeName = "FrameActionBody";
    static readonly fields: FieldList;
    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FrameActionBody;
    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FrameActionBody;
    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FrameActionBody;
    static equals(a: FrameActionBody | PlainMessage<FrameActionBody> | undefined, b: FrameActionBody | PlainMessage<FrameActionBody> | undefined): boolean;
}
//# sourceMappingURL=message_pb.d.ts.map