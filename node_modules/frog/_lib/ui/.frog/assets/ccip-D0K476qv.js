import{s as h,A as O,t as L,f as R,b as x,d as A,B as l,h as w,i as g,j as m,I as y,k as M,l as P,m as S,H as b,n as $}from"../main.js";const D={inputs:[{name:"message",type:"string"}],name:"Error",type:"error"},j={inputs:[{name:"reason",type:"uint256"}],name:"Panic",type:"error"};function q(a){const{abi:t,data:r}=a,s=h(r,0,4);if(s==="0x")throw new O;const e=[...t||[],D,j].find(n=>n.type==="error"&&s===L(R(n)));if(!e)throw new x(s,{docsPath:"/docs/contract/decodeErrorResult"});return{abiItem:e,args:"inputs"in e&&e.inputs&&e.inputs.length>0?A(e.inputs,h(r,4)):void 0,errorName:e.name}}class v extends l{constructor({callbackSelector:t,cause:r,data:s,extraData:i,sender:e,urls:n}){super(r.shortMessage||"An error occurred while fetching for an offchain result.",{cause:r,metaMessages:[...r.metaMessages||[],r.metaMessages?.length?"":[],"Offchain Gateway Call:",n&&["  Gateway URL(s):",...n.map(u=>`    ${w(u)}`)],`  Sender: ${e}`,`  Data: ${s}`,`  Callback selector: ${t}`,`  Extra data: ${i}`].flat()}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupError"})}}class C extends l{constructor({result:t,url:r}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${w(r)}`,`Response: ${g(t)}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupResponseMalformedError"})}}class I extends l{constructor({sender:t,to:r}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${r}`,`OffchainLookup sender address: ${t}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupSenderMismatchError"})}}function T(a,t){if(!m(a,{strict:!1}))throw new y({address:a});if(!m(t,{strict:!1}))throw new y({address:t});return a.toLowerCase()===t.toLowerCase()}const H="0x556f1830",G={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function N(a,{blockNumber:t,blockTag:r,data:s,to:i}){const{args:e}=q({data:s,abi:[G]}),[n,u,o,c,p]=e,{ccipRead:d}=a,E=d&&typeof d?.request=="function"?d.request:_;try{if(!T(i,n))throw new I({sender:n,to:i});const f=await E({data:o,sender:n,urls:u}),{data:k}=await M(a,{blockNumber:t,blockTag:r,data:P([c,S([{type:"bytes"},{type:"bytes"}],[f,p])]),to:i});return k}catch(f){throw new v({callbackSelector:c,cause:f,data:s,extraData:p,sender:n,urls:u})}}async function _({data:a,sender:t,urls:r}){let s=new Error("An unknown error occurred.");for(let i=0;i<r.length;i++){const e=r[i],n=e.includes("{data}")?"GET":"POST",u=n==="POST"?{data:a,sender:t}:void 0;try{const o=await fetch(e.replace("{sender}",t).replace("{data}",a),{body:JSON.stringify(u),method:n});let c;if(o.headers.get("Content-Type")?.startsWith("application/json")?c=(await o.json()).data:c=await o.text(),!o.ok){s=new b({body:u,details:c?.error?g(c.error):o.statusText,headers:o.headers,status:o.status,url:e});continue}if(!$(c)){s=new C({result:c,url:e});continue}return c}catch(o){s=new b({body:u,details:o.message,url:e})}}throw s}export{_ as ccipRequest,N as offchainLookup,G as offchainLookupAbiItem,H as offchainLookupSignature};
